<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Max Token Tracker</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      padding: 24px;
      max-width: 900px;
      margin: 0 auto;
    }
    h1 { color: #58a6ff; margin-bottom: 4px; font-size: 24px; }
    .subtitle { color: #8b949e; margin-bottom: 0; }
    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }
    .tier-select {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .tier-select label { color: #8b949e; font-size: 13px; }
    .tier-select select {
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #30363d;
      background: #21262d;
      color: #c9d1d9;
      font-size: 14px;
      cursor: pointer;
    }
    .card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 16px;
    }
    .card h2 { font-size: 14px; color: #8b949e; margin-bottom: 12px; text-transform: uppercase; }
    .progress-row { display: flex; align-items: center; margin-bottom: 16px; }
    .progress-row:last-child { margin-bottom: 0; }
    .progress-label { width: 100px; font-size: 13px; color: #8b949e; }
    .progress-container { flex: 1; background: #21262d; border-radius: 6px; height: 24px; overflow: hidden; }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #238636, #2ea043);
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 8px;
      font-weight: 600;
      font-size: 12px;
      min-width: 40px;
    }
    .progress-bar.warning { background: linear-gradient(90deg, #9e6a03, #d29922); }
    .progress-bar.danger { background: linear-gradient(90deg, #da3633, #f85149); }
    .progress-info { width: 140px; text-align: right; font-size: 12px; color: #8b949e; margin-left: 12px; }

    .btn-sm {
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      margin-left: 8px;
      width: auto;
    }
    .btn-danger { background: #da3633; color: white; }
    .btn-danger:hover { background: #f85149; }
    .btn-log { background: #1f6feb; color: white; }
    .btn-log:hover { background: #388bfd; }

    .compare-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #21262d;
      font-size: 13px;
      color: #8b949e;
    }
    .compare-row input {
      padding: 6px;
      font-size: 13px;
    }

    .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-top: 16px; padding-top: 16px; border-top: 1px solid #21262d; }
    .stat { text-align: center; }
    .stat-value { font-size: 20px; font-weight: 600; color: #f0f6fc; }
    .stat-label { font-size: 11px; color: #8b949e; margin-top: 4px; }

    .chart-container { height: 200px; }

    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #21262d; }
    th { color: #8b949e; font-weight: 500; }

    .form-row { display: flex; gap: 12px; margin-bottom: 12px; }
    .form-group { flex: 1; }
    .form-group label { display: block; font-size: 12px; color: #8b949e; margin-bottom: 4px; }
    input, button, select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #30363d;
      background: #0d1117;
      color: #c9d1d9;
      font-size: 14px;
    }
    input:focus, select:focus { outline: none; border-color: #58a6ff; }
    button {
      background: #238636;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }
    button:hover { background: #2ea043; }

    .delete-btn {
      background: none;
      border: none;
      color: #f85149;
      cursor: pointer;
      padding: 4px 8px;
      width: auto;
    }
    .delete-btn:hover { text-decoration: underline; }
    .empty { color: #8b949e; text-align: center; padding: 24px; }
    .session-tag {
      display: inline-block;
      background: #21262d;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      color: #58a6ff;
    }

    .calibration-log { margin-top: 16px; padding-top: 16px; border-top: 1px solid #21262d; }
    .calibration-log h3 { font-size: 12px; color: #8b949e; margin-bottom: 8px; }
    .calibration-entry {
      background: #21262d;
      padding: 8px 12px;
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .calibration-entry .time { color: #8b949e; }
    .calibration-entry .data { color: #f0f6fc; margin-top: 4px; }
  </style>
</head>
<body>
  <div class="header-row">
    <div>
      <h1>Claude Token Tracker</h1>
      <p class="subtitle">Usage Monitor</p>
    </div>
    <div class="tier-select">
      <label>Plan:</label>
      <select id="tierSelect" onchange="saveTier()">
        <option value="pro">Pro</option>
        <option value="max5x">Max 5x</option>
        <option value="max20x">Max 20x</option>
      </select>
    </div>
  </div>

  <div class="card">
    <h2>Usage</h2>

    <div class="progress-row">
      <div class="progress-label">Session</div>
      <div class="progress-container">
        <div class="progress-bar" id="sessionBar">0%</div>
      </div>
      <div class="progress-info" id="sessionInfo">- / 2.5M</div>
      <button class="btn-sm btn-danger" onclick="markLimit('session')">Limit</button>
    </div>

    <div class="progress-row">
      <div class="progress-label">Weekly</div>
      <div class="progress-container">
        <div class="progress-bar" id="weeklyBar">0%</div>
      </div>
      <div class="progress-info" id="weeklyInfo">- / 17.4M</div>
      <button class="btn-sm btn-danger" onclick="markLimit('weekly')">Limit</button>
    </div>

    <div class="progress-row">
      <div class="progress-label">Monthly</div>
      <div class="progress-container">
        <div class="progress-bar" id="monthlyBar">0%</div>
      </div>
      <div class="progress-info" id="monthlyInfo">- / 45M</div>
    </div>

    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="sessionTokens">-</div>
        <div class="stat-label">Session</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="weeklyTokens">-</div>
        <div class="stat-label">Weekly</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="monthlyTokens">-</div>
        <div class="stat-label">Monthly</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="apiCalls">-</div>
        <div class="stat-label">Calls</div>
      </div>
    </div>

    <div class="compare-row">
      <span>Claude:</span>
      <input type="text" id="claudeSessionPct" placeholder="%" style="width:45px;text-align:center;">
      <span>session</span>
      <input type="text" id="claudeWeeklyPct" placeholder="%" style="width:45px;text-align:center;">
      <span>weekly</span>
      <button class="btn-sm btn-log" onclick="logComparison()">Log</button>
      <span style="margin-left:auto;">Resets:</span>
      <input type="text" id="resetTime" placeholder="2:45" style="width:50px;text-align:center;" title="Session reset time">
      <span>sess</span>
      <input type="text" id="weeklyResetDay" placeholder="Thu" style="width:45px;text-align:center;" title="Weekly reset day">
      <span>wk</span>
    </div>
  </div>

  <div class="card">
    <h2>Session API Calls</h2>
    <div class="chart-container">
      <canvas id="usageChart"></canvas>
    </div>
  </div>

  <div class="card">
    <h2>Calibration Log</h2>
    <p style="font-size: 12px; color: #8b949e; margin-bottom: 12px;">
      When Claude shows "limit reached", click "Session Hit Limit" to record the actual limit point.
    </p>
    <div id="calibrationLog"></div>
  </div>

  <div class="card">
    <h2>Recent API Calls</h2>
    <table id="sessionsTable">
      <thead>
        <tr><th>Time</th><th>Input</th><th>Output</th><th>Total</th><th>Model</th><th></th></tr>
      </thead>
      <tbody id="sessionsList"></tbody>
    </table>
    <div id="emptyState" class="empty" style="display: none">No sessions recorded yet</div>
  </div>

  <script>
    let chart = null;
    let usageData = {
      monthlyLimit: 45000000,
      weeklyLimit: 17400000,
      sessionLimit: 2500000,
      resetDay: 1,
      sessions: [],
      calibrations: [],
      tier: 'max5x'
    };

    const TIER_LIMITS = {
      pro: {
        session: 500000,      // ~500K
        weekly: 3500000,      // ~3.5M
        monthly: 10000000     // ~10M
      },
      max5x: {
        session: 2000000,     // ~2.0M (calibrated)
        weekly: 20000000,     // ~20M (calibrated)
        monthly: 45000000     // ~45M
      },
      max20x: {
        session: 8000000,     // ~8M (4x max5x)
        weekly: 80000000,     // ~80M (4x max5x)
        monthly: 180000000    // ~180M
      }
    };

    function formatNumber(n) {
      if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
      if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
      return n.toString();
    }

    function parseResetTime(str) {
      if (!str) return null;
      // Parse formats: "3:18", "3h 18m", "3 hr 18 min", "3h18m"
      const match = str.match(/(\d+)\s*[h:]\s*(\d+)/i);
      if (match) {
        return parseInt(match[1]) * 60 + parseInt(match[2]);
      }
      // Just minutes
      const minMatch = str.match(/^(\d+)$/);
      if (minMatch) return parseInt(minMatch[1]);
      return null;
    }

    function getSessionStart() {
      const resetInput = document.getElementById('resetTime').value;
      const resetMinutes = parseResetTime(resetInput);

      if (resetMinutes) {
        // Session is 5 hours (300 min). If reset in X min, started (300 - X) min ago
        const minutesAgo = 300 - resetMinutes;
        return new Date(Date.now() - minutesAgo * 60 * 1000);
      }

      // Default: 5-hour rolling window
      return new Date(Date.now() - 5 * 60 * 60 * 1000);
    }

    function getWeekStart() {
      const now = new Date();
      const dayInput = document.getElementById('weeklyResetDay')?.value?.toLowerCase() || '';

      // Parse day name to number (0=Sun, 1=Mon, etc)
      const dayMap = {sun:0, mon:1, tue:2, wed:3, thu:4, fri:5, sat:6};
      let resetDay = 1; // Default Monday
      for (const [name, num] of Object.entries(dayMap)) {
        if (dayInput.startsWith(name)) {
          resetDay = num;
          break;
        }
      }

      const currentDay = now.getDay();
      let daysAgo = currentDay - resetDay;
      if (daysAgo < 0) daysAgo += 7;

      const start = new Date(now);
      start.setDate(start.getDate() - daysAgo);
      start.setHours(0, 0, 0, 0);
      return start;
    }

    function getMonthStart() {
      const now = new Date();
      const resetDay = usageData.resetDay || 1;
      let start = new Date(now.getFullYear(), now.getMonth(), resetDay, 0, 0, 0);
      if (now.getDate() < resetDay) {
        start.setMonth(start.getMonth() - 1);
      }
      return start;
    }

    function getSessionsInRange(start) {
      return usageData.sessions.filter(s => new Date(s.timestamp) >= start);
    }

    function sumTokens(sessions) {
      return sessions.reduce((sum, s) => sum + (s.input || 0) + (s.output || 0), 0);
    }

    function getTimeLeft() {
      const resetInput = document.getElementById('resetTime').value;
      const resetMinutes = parseResetTime(resetInput);
      if (resetMinutes) {
        const h = Math.floor(resetMinutes / 60);
        const m = resetMinutes % 60;
        return `${h}h ${m}m`;
      }
      return '~5h';
    }

    function updateProgressBar(barId, infoId, used, limit) {
      const percent = Math.min(100, (used / limit) * 100);
      const bar = document.getElementById(barId);
      bar.style.width = Math.max(percent, 3) + '%';
      bar.textContent = percent.toFixed(1) + '%';
      bar.className = 'progress-bar' + (percent > 80 ? ' danger' : percent > 60 ? ' warning' : '');
      document.getElementById(infoId).textContent = `${formatNumber(used)} / ${formatNumber(limit)}`;
    }

    function getTierLimits() {
      const tier = usageData.tier || 'max5x';
      return TIER_LIMITS[tier] || TIER_LIMITS.max5x;
    }

    function updateUI() {
      // Set tier dropdown
      document.getElementById('tierSelect').value = usageData.tier || 'max5x';

      const limits = getTierLimits();
      const sessionStart = getSessionStart();
      const sessionSessions = getSessionsInRange(sessionStart);
      const weeklySessions = getSessionsInRange(getWeekStart());
      const monthlySessions = getSessionsInRange(getMonthStart());

      const sessionUsed = sumTokens(sessionSessions);
      const weeklyUsed = sumTokens(weeklySessions);
      const monthlyUsed = sumTokens(monthlySessions);

      updateProgressBar('sessionBar', 'sessionInfo', sessionUsed, limits.session);
      updateProgressBar('weeklyBar', 'weeklyInfo', weeklyUsed, limits.weekly);
      updateProgressBar('monthlyBar', 'monthlyInfo', monthlyUsed, limits.monthly);

      document.getElementById('sessionTokens').textContent = formatNumber(sessionUsed);
      document.getElementById('weeklyTokens').textContent = formatNumber(weeklyUsed);
      document.getElementById('monthlyTokens').textContent = formatNumber(monthlyUsed);
      document.getElementById('apiCalls').textContent = sessionSessions.length;

      // Sessions table
      const tbody = document.getElementById('sessionsList');
      const empty = document.getElementById('emptyState');

      if (usageData.sessions.length === 0) {
        tbody.innerHTML = '';
        empty.style.display = 'block';
      } else {
        empty.style.display = 'none';
        tbody.innerHTML = usageData.sessions
          .slice()
          .reverse()
          .slice(0, 50)
          .map((s, i) => {
            const idx = usageData.sessions.length - 1 - i;
            const dt = new Date(s.timestamp);
            const time = dt.toLocaleTimeString();
            const total = (s.input || 0) + (s.output || 0);
            const model = (s.note || '').replace('auto:', '').replace('sync:', '').trim() || '-';
            return `<tr>
              <td>${time}</td>
              <td>${formatNumber(s.input || 0)}</td>
              <td>${formatNumber(s.output || 0)}</td>
              <td>${formatNumber(total)}</td>
              <td><span class="session-tag">${model}</span></td>
              <td><button class="delete-btn" onclick="deleteSession(${idx})">x</button></td>
            </tr>`;
          })
          .join('');
      }

      updateChart(sessionSessions);
      updateCalibrationLog();
    }

    function updateChart(sessions) {
      // Group by minute for per-call visualization
      const recentSessions = sessions.slice(-100);
      const labels = recentSessions.map((s, i) => {
        const dt = new Date(s.timestamp);
        return dt.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
      });
      const data = recentSessions.map(s => (s.input || 0) + (s.output || 0));

      if (chart) {
        chart.data.labels = labels;
        chart.data.datasets[0].data = data;
        chart.update();
      } else {
        chart = new Chart(document.getElementById('usageChart'), {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              label: 'Tokens',
              data,
              backgroundColor: recentSessions.map(s => {
                const note = s.note || '';
                if (note.includes('opus')) return '#238636';
                if (note.includes('haiku')) return '#1f6feb';
                return '#6e7681';
              }),
              borderRadius: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
              x: {
                grid: { display: false },
                ticks: { color: '#8b949e', maxRotation: 45, font: { size: 10 } }
              },
              y: {
                grid: { color: '#21262d' },
                ticks: { color: '#8b949e' }
              }
            }
          }
        });
      }
    }

    function updateCalibrationLog() {
      const container = document.getElementById('calibrationLog');
      const calibrations = usageData.calibrations || [];

      if (calibrations.length === 0) {
        container.innerHTML = '<p style="color: #6e7681; font-size: 12px;">No calibration points recorded yet.</p>';
        return;
      }

      container.innerHTML = calibrations.slice().reverse().slice(0, 10).map(c => {
        if (c.type === 'comparison') {
          return `<div class="calibration-entry">
            <div class="time">${new Date(c.timestamp).toLocaleString()}</div>
            <div class="data">
              Ours: ${formatNumber(c.ourSession)} session, ${formatNumber(c.ourWeekly)} weekly |
              Claude: ${c.claudeSession || '-'}% session, ${c.claudeWeekly || '-'}% weekly |
              Implied: ${c.impliedSessionLimit ? formatNumber(c.impliedSessionLimit) : '-'} / ${c.impliedWeeklyLimit ? formatNumber(c.impliedWeeklyLimit) : '-'}
            </div>
          </div>`;
        }
        return `<div class="calibration-entry">
          <div class="time">${new Date(c.timestamp).toLocaleString()}</div>
          <div class="data">
            ${c.type || 'session'} limit | Tracked: ${formatNumber(c.trackedTokens)} | Claude: ${c.claudePercent}% | Implied: ${formatNumber(c.impliedLimit || 0)}
          </div>
        </div>`;
      }).join('');
    }

    async function logComparison() {
      const sessionPct = parseFloat(document.getElementById('claudeSessionPct').value) || 0;
      const weeklyPct = parseFloat(document.getElementById('claudeWeeklyPct').value) || 0;

      if (!sessionPct && !weeklyPct) {
        alert('Enter at least one percentage from Claude');
        return;
      }

      const sessionTokens = sumTokens(getSessionsInRange(getSessionStart()));
      const weeklyTokens = sumTokens(getSessionsInRange(getWeekStart()));

      const comparison = {
        timestamp: new Date().toISOString(),
        type: 'comparison',
        ourSession: sessionTokens,
        ourWeekly: weeklyTokens,
        claudeSession: sessionPct,
        claudeWeekly: weeklyPct,
        impliedSessionLimit: sessionPct > 0 ? Math.round(sessionTokens / (sessionPct / 100)) : null,
        impliedWeeklyLimit: weeklyPct > 0 ? Math.round(weeklyTokens / (weeklyPct / 100)) : null
      };

      await fetch('/api/calibration', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(comparison)
      });

      document.getElementById('claudeSessionPct').value = '';
      document.getElementById('claudeWeeklyPct').value = '';

      loadData();
    }

    async function markLimit(type) {
      const claudePercent = prompt(`What percentage did Claude show for ${type} when limit was hit?`);
      if (!claudePercent) return;

      const pct = parseFloat(claudePercent);
      let tokens, limitType;

      if (type === 'session') {
        tokens = sumTokens(getSessionsInRange(getSessionStart()));
        limitType = 'session';
      } else if (type === 'weekly') {
        tokens = sumTokens(getSessionsInRange(getWeekStart()));
        limitType = 'weekly';
      }

      const impliedLimit = pct > 0 ? Math.round(tokens / (pct / 100)) : 0;

      const calibration = {
        timestamp: new Date().toISOString(),
        type: limitType,
        trackedTokens: tokens,
        claudePercent: pct,
        impliedLimit: impliedLimit
      };

      await fetch('/api/calibration', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(calibration)
      });

      alert(`${type} calibration recorded!\nTracked: ${formatNumber(tokens)}\nClaude: ${pct}%\nImplied limit: ${formatNumber(impliedLimit)}`);
      loadData();
    }

    async function saveTier() {
      const tier = document.getElementById('tierSelect').value;
      await fetch('/api/settings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tier })
      });
      usageData.tier = tier;
      updateUI();
    }

    async function loadData() {
      const res = await fetch('/api/usage');
      usageData = await res.json();
      updateUI();
    }

    async function deleteSession(idx) {
      if (!confirm('Delete this entry?')) return;
      await fetch('/api/delete-session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ index: idx })
      });
      loadData();
    }

    // Session countdown timer
    let sessionEndTime = null;

    function startSessionTimer(minutesLeft) {
      sessionEndTime = Date.now() + (minutesLeft * 60 * 1000);
      localStorage.setItem('sessionEndTime', sessionEndTime);
    }

    function updateCountdown() {
      const input = document.getElementById('resetTime');
      if (!sessionEndTime) {
        sessionEndTime = parseInt(localStorage.getItem('sessionEndTime')) || null;
      }
      if (sessionEndTime) {
        const remaining = sessionEndTime - Date.now();
        if (remaining > 0) {
          const mins = Math.floor(remaining / 60000);
          const secs = Math.floor((remaining % 60000) / 1000);
          input.value = `${Math.floor(mins/60)}:${String(mins%60).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
        } else {
          input.value = '0:00:00';
          sessionEndTime = null;
          localStorage.removeItem('sessionEndTime');
        }
      }
    }

    // Persist inputs to localStorage
    const resetTimeInput = document.getElementById('resetTime');
    const weeklyResetInput = document.getElementById('weeklyResetDay');

    weeklyResetInput.value = localStorage.getItem('weeklyResetDay') || '';

    resetTimeInput.addEventListener('change', () => {
      const mins = parseResetTime(resetTimeInput.value);
      if (mins) {
        startSessionTimer(mins);
      }
    });
    weeklyResetInput.addEventListener('input', () => {
      localStorage.setItem('weeklyResetDay', weeklyResetInput.value);
      updateUI();
    });

    // Initialize countdown display
    updateCountdown();
    setInterval(updateCountdown, 1000);

    loadData();
    setInterval(loadData, 10000);
  </script>
</body>
</html>
